<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sensors</title>
		<script src="https://cdn.tailwindcss.com"></script>
		<style>
			@media (max-width: 1600px) {
				.sensor-header {
					font-size: 1.5rem !important;
					text-align: center !important;
				}

				.sensor-hint {
					display: none !important;
				}
			}
		</style>
	</head>

	<body class="bg-gray-50">
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
		<script type="module">
			import {
				onMount,
				onCleanup,
				createSignal,
				createEffect,
				For,
				createMemo,
			} from 'https://esm.sh/solid-js@1.8.1';
			import { render } from 'https://esm.sh/solid-js@1.8.1/web';
			import html from 'https://esm.sh/solid-js@1.8.1/html';

			const SENSORS = [
				{
					name: 'temperature',
					color: 'rgb(255, 99, 132)',
					unit: 'Â°C',
					maxValue: 26,
					warning: 'Temperature is too high, turn on a fan or open a window.',
				},
				{
					name: 'humidity',
					color: 'rgb(54, 162, 235)',
					unit: '%',
					minValue: 40,
					warning: 'Humidity is too low, consider using a humidifier.',
				},
				{
					name: 'air_quality',
					color: 'rgb(75, 192, 192)',
					unit: 'AQI',
					maxValue: 1000,
					warning: 'Air quality is poor, consider opening a window.',
				},
				{
					name: 'co',
					color: 'rgb(153, 102, 255)',
					unit: 'CO index',
					maxValue: 1000,
					warning: 'CO levels are too high, evacuate the area immediately.',
				},
				{
					name: 'light',
					color: 'rgb(255, 206, 86)',
					unit: 'lux',
				},
			];

			// Date range defaults: start = today - 2 years, end = today
			const today = new Date();
			const start = new Date(today);

			if (window.innerWidth <= 1600) {
				// For smaller screens, default to last 6 months
				start.setDate(today.getDate() - 2);
			} else {
				// For larger screens, default to last 2 years
				start.setFullYear(today.getFullYear() - 2);
			}

			// Date range state
			const [minDay, setMinDay] = createSignal(start.getDate());
			const [minMonth, setMinMonth] = createSignal(start.getMonth() + 1);
			const [minYear, setMinYear] = createSignal(start.getFullYear());
			const [maxDay, setMaxDay] = createSignal(today.getDate());
			const [maxMonth, setMaxMonth] = createSignal(today.getMonth() + 1);
			const [maxYear, setMaxYear] = createSignal(today.getFullYear());

			function toDate(day, month, year, endOfDay = false) {
				if (![day, month, year].every(n => Number.isFinite(n) && n > 0)) return null;
				const d = new Date(year, month - 1, day);
				if (Number.isNaN(d.getTime())) return null;
				if (endOfDay) d.setHours(23, 59, 59, 999);
				else d.setHours(0, 0, 0, 0);
				return d;
			}
			const minDate = createMemo(() => toDate(minDay(), minMonth(), minYear(), false));
			const maxDate = createMemo(() => toDate(maxDay(), maxMonth(), maxYear(), true));

			function filterByRange(list) {
				const min = minDate();
				const max = maxDate();
				if (!min && !max) return list;
				return list.filter(([, ts]) => {
					const d = new Date(ts);
					if (min && d < min) return false;
					if (max && d > max) return false;
					return true;
				});
			}

			async function fetchSensor(name) {
				try {
					const response = await fetch(`/${name}`);

					if (!response.ok) {
						throw new Error(`Error fetching sensor ${name}: ${response.statusText}`);
					}

					return await response.text();
				} catch (error) {
					console.error(error);
					return null;
				}
			}

			function parseDateString(dateString) {
				const date = new Date(dateString);

				if (window.innerWidth > 1600) {
					// Parse to day month and time
					return date.toLocaleDateString('nl-NL', {
						day: '2-digit',
						month: '2-digit',
						hour: '2-digit',
						minute: '2-digit',
					});
				}

				// Return the time only
				return date.toLocaleTimeString('nl-NL', {
					hour: '2-digit',
					minute: '2-digit',
				});
			}

			function SensorCard(props) {
				let canvasRef;
				let chartInstance;

				createEffect(() => {
					// Clean up existing chart before re-creating or if data/canvas is missing
					if (chartInstance) {
						chartInstance.destroy();
						chartInstance = null;
					}

					// If no data or ref, stop here
					if (!canvasRef || props.data.length === 0) {
						return;
					}

					const ctx = canvasRef.getContext('2d');
					const labels = props.data.map(value => parseDateString(value[1]) || 'N/A');
					const values = props.data.map(value => value[0] || 0);

					chartInstance = new Chart(ctx, {
						type: 'line',
						data: {
							labels: labels,
							datasets: [
								{
									label: props.name,
									data: values,
									borderColor: props.color,
									backgroundColor: props.color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
									tension: 0.1,
								},
							],
						},
						options: {
							responsive: true,
							maintainAspectRatio: false,
							plugins: {
								title: {
									display: true,
									text: `Latest ${props.name.charAt(0).toUpperCase() + props.name.slice(1)} Data`,
								},
								legend: {
									display: false,
								},
							},
							scales: {
								y: {
									title: {
										display: true,
										text: `${props.name.charAt(0).toUpperCase() + props.name.slice(1)} (${
											props.unit
										})`,
									},
								},
								x: {
									ticks: {
										font: {
											size: 10,
										},
									},
								},
							},
						},
					});
				});

				onCleanup(() => {
					if (chartInstance) {
						chartInstance.destroy();
						chartInstance = null;
					}
				});

				function showWarning() {
					if (props.minValue && props.data.length > 0) {
						const latestValue = props.data[props.data.length - 1]?.[0];
						if (latestValue < props.minValue) {
							return true;
						}
					} else if (props.maxValue && props.data.length > 0) {
						const latestValue = props.data[props.data.length - 1]?.[0];
						if (latestValue > props.maxValue) {
							return true;
						}
					}

					return false;
				}

				return html`
					<div id=${'chart-' + props.name} class="bg-white rounded-lg shadow-md pt-4 px-4 pb-2">
						<h3
							class=${() =>
								`sensor-header text-lg font-semibold mb-2 ${showWarning() ? 'text-red-500' : 'text-gray-800'}`}
						>
							${props.name.charAt(0).toUpperCase() + props.name.slice(1)}
						</h3>

						<div class="text-center">
							<p class="sensor-hint text-gray-600 text-sm mb-2">
								${showWarning()
									? html` <span class="text-red-500">${props.warning}</span> `
									: html`
											<span
												>Latest value:
												${props.data.length > 0 ? props.data[props.data.length - 1][0] : 'N/A'}
												${props.unit}</span
											>
										`}
							</p>

							<div class="mt-4">
								${props.data.length > 0
									? html`<div style="height: 300px; position: relative">
												<canvas ref=${el => (canvasRef = el)}></canvas>
											</div>
											<p class="text-gray-500 text-sm mt-6 italic text-center text-xs">
												Last updated: ${new Date().toISOString()}
											</p>`
									: html`
											<div
												class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded"
											>
												No data available for ${props.name}.
											</div>
										`}
							</div>
						</div>
					</div>
				`;
			}

			function App() {
				const [sensorsData, setSensorsData] = createSignal({});
				const [loading, setLoading] = createSignal(true);
				const [errors, setErrors] = createSignal({});

				async function fetchAllSensors() {
					setLoading(true);

					const newData = {};
					const newErrors = {};

					for (const sensor of SENSORS) {
						const data = await fetchSensor(sensor.name);

						if (!data) {
							newErrors[sensor.name] = `Failed to fetch data for ${sensor}.`;
							continue;
						}

						const sensorData = data
							.split('\n')
							.filter(line => line.trim())
							.map(line => line.split('|').map(value => value.trim()));

						if (sensorData.length === 0) {
							newErrors[sensor.name] = `No data available for ${sensor}.`;
						} else {
							newData[sensor.name] = sensorData;
						}
					}

					setSensorsData(newData);
					setErrors(newErrors);

					setLoading(false);
				}

				onMount(() => {
					fetchAllSensors();

					// Refresh data every 15 minutes
					setInterval(fetchAllSensors, 15 * 60 * 1000);
				});

				return html`
					<div class="container mx-auto px-4 py-8 max-w-8xl">
						<h1 class="text-3xl font-bold text-gray-900 mb-6">Sensors at home</h1>

						<div class="mb-4">
							<p class="text-gray-700 mb-4">
								This page displays the current values of various sensors in the house.
							</p>
						</div>

						<div class="bg-white rounded-lg shadow-md py-3 px-4 mb-4">
							<h3 class="font-semibold mb-2">
								${() => (loading() ? 'Loading sensors...' : 'Filter by date range')}
							</h3>

							<div class="flex md:flex-row flex-col mb-4">
								<div class="flex-1">
									<div class="text-xs text-gray-500 font-medium mb-1">From</div>

									<div class="flex gap-x-2 items-center">
										<div>
											<input
												name="min_day"
												type="number"
												min="1"
												max="31"
												value=${minDay()}
												onInput=${e => setMinDay(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-20 mr-2"
											/>
											<label for="day" class="text-gray-600 text-sm">days</label>
										</div>
										<div>
											<input
												name="min_month"
												type="number"
												min="1"
												max="12"
												value=${minMonth()}
												onInput=${e => setMinMonth(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-20 mr-2"
											/>
											<label for="month" class="text-gray-600 text-sm">months</label>
										</div>
										<div>
											<input
												name="min_year"
												type="number"
												min="2020"
												max="2030"
												value=${minYear()}
												onInput=${e => setMinYear(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-24 mr-2"
											/>
											<label for="year" class="text-gray-600 text-sm">years</label>
										</div>
									</div>
								</div>

								<div class="flex-1">
									<div class="text-xs text-gray-500 font-medium mb-1">To</div>

									<div class="flex gap-x-2 items-center">
										<div>
											<input
												name="max_day"
												type="number"
												min="1"
												max="31"
												value=${maxDay()}
												onInput=${e => setMaxDay(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-20 mr-2"
											/>
											<label for="day" class="text-gray-600 text-sm">days</label>
										</div>
										<div>
											<input
												name="max_month"
												type="number"
												min="1"
												max="12"
												value=${maxMonth()}
												onInput=${e => setMaxMonth(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-20 mr-2"
											/>
											<label for="month" class="text-gray-600 text-sm">months</label>
										</div>
										<div>
											<input
												name="max_year"
												type="number"
												min="2020"
												max="2030"
												value=${maxYear()}
												onInput=${e => setMaxYear(e.currentTarget.valueAsNumber)}
												class="border border-gray-300 rounded px-2 py-1 text-sm w-24 mr-2"
											/>
											<label for="year" class="text-gray-600 text-sm">years</label>
										</div>
									</div>
								</div>
							</div>

							<div class="text-sm text-gray-500 underline">
								${() => {
									const min = minDate();
									const max = maxDate();
									const fmt = d =>
										d.toLocaleDateString('nl-NL', {
											day: '2-digit',
											month: '2-digit',
											year: 'numeric',
										});
									return min && max
										? `Showing ${fmt(min)} - ${fmt(max)}`
										: min
											? `From ${fmt(min)}`
											: max
												? `Up to ${fmt(max)}`
												: 'Showing all data';
								}}
							</div>
						</div>

						<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
							${() =>
								!loading() &&
								SENSORS.map(sensor =>
									SensorCard({
										...sensor,
										data: filterByRange(sensorsData()[sensor.name] || []),
									}),
								)}
						</div>
					</div>
				`;
			}

			render(App, document.body);
		</script>
	</body>
</html>
